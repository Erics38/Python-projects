name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy to'
        required: true
        default: 'demo'
        type: choice
        options:
        - demo
        - dev
        - prod
      terraform_action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # =============================================================================
  # CONTINUOUS INTEGRATION (CI) JOBS
  # =============================================================================
  
  validate:
    name: ğŸ” Validate Code & Infrastructure
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install backend dependencies
      working-directory: docker-hello-world/backend
      run: npm install

    - name: Run application tests
      working-directory: docker-hello-world/backend
      run: |
        echo "ğŸ§ª Running application tests..."
        # npm test (add when tests are available)
        echo "âœ… Tests passed (placeholder)"

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Format Check
      working-directory: docker-hello-world/infrastructure
      timeout-minutes: 2
      run: |
        echo "ğŸ¨ Checking Terraform formatting..."
        echo "Files to check:"
        find . -name "*.tf" -type f | head -10
        echo "Running format check on main directory..."
        terraform fmt -check -diff . || true
        echo "Running format check on modules..."
        find ./modules -name "*.tf" -type f -exec terraform fmt -check -diff {} \; || true
        echo "Format check completed"

    - name: Terraform Validation
      working-directory: docker-hello-world/infrastructure
      timeout-minutes: 5
      run: |
        echo "âœ… Validating Terraform configuration..."
        terraform init -backend=false
        terraform validate

  # security-scan:
  #   name: ğŸ›¡ï¸ Security Scanning
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #
  #   - name: Build Docker images for scanning
  #     working-directory: docker-hello-world
  #     run: |
  #       echo "ğŸ”¨ Building Docker images for security scanning..."
  #       docker build -t guestbook-frontend:scan -f Dockerfile .
  #       docker build -t guestbook-backend:scan -f Dockerfile.backend .
  #
  #   - name: Run Trivy security scan on frontend
  #     uses: aquasecurity/trivy-action@master
  #     with:
  #       image-ref: guestbook-frontend:scan
  #       format: 'sarif'
  #       output: 'trivy-frontend-results.sarif'
  #
  #   - name: Run Trivy security scan on backend
  #     uses: aquasecurity/trivy-action@master
  #     with:
  #       image-ref: guestbook-backend:scan
  #       format: 'sarif'
  #       output: 'trivy-backend-results.sarif'
  #
  #   # Security uploads disabled due to GitHub integration permissions
  #   # - name: Upload Frontend Trivy scan results to GitHub Security tab
  #   #   uses: github/codeql-action/upload-sarif@v3
  #   #   if: always()
  #   #   with:
  #   #     sarif_file: 'trivy-frontend-results.sarif'
  #   #     category: 'trivy-frontend'
  #
  #   # - name: Upload Backend Trivy scan results to GitHub Security tab
  #   #   uses: github/codeql-action/upload-sarif@v3
  #   #   if: always()
  #   #   with:
  #   #     sarif_file: 'trivy-backend-results.sarif'
  #   #     category: 'trivy-backend'
  #
  #   - name: Check for critical vulnerabilities
  #     run: |
  #       echo "ğŸ” Checking for HIGH/CRITICAL vulnerabilities..."
  #       docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  #         aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL \
  #         guestbook-frontend:scan
  #       docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  #         aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL \
  #         guestbook-backend:scan

  # =============================================================================
  # CONTINUOUS DEPLOYMENT (CD) JOBS
  # =============================================================================

  build-and-push:
    name: ğŸ—ï¸ Build & Push Container Images
    needs: [validate]
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main'
    outputs:
      frontend-image: ${{ steps.image-tags.outputs.frontend-image }}
      backend-image: ${{ steps.image-tags.outputs.backend-image }}
      ecr-registry: ${{ steps.login-ecr.outputs.registry }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repositories if they don't exist
      run: |
        echo "ğŸ“¦ Ensuring ECR repositories exist..."
        aws ecr describe-repositories --repository-names guestbook-frontend || \
          aws ecr create-repository --repository-name guestbook-frontend \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256
        
        aws ecr describe-repositories --repository-names guestbook-backend || \
          aws ecr create-repository --repository-name guestbook-backend \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256

    - name: Build, tag, and push images
      working-directory: docker-hello-world
      run: |
        echo "ğŸ”¨ Building container images..."
        
        # Build images
        docker build -t guestbook-frontend:${{ env.IMAGE_TAG }} -f Dockerfile .
        docker build -t guestbook-backend:${{ env.IMAGE_TAG }} -f Dockerfile.backend .
        
        echo "ğŸ·ï¸ Tagging images for ECR..."
        
        # Tag for ECR
        docker tag guestbook-frontend:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/guestbook-frontend:${{ env.IMAGE_TAG }}
        docker tag guestbook-backend:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/guestbook-backend:${{ env.IMAGE_TAG }}
        docker tag guestbook-frontend:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/guestbook-frontend:latest
        docker tag guestbook-backend:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/guestbook-backend:latest
        
        echo "ğŸš€ Pushing images to ECR..."
        
        # Push to ECR
        docker push ${{ steps.login-ecr.outputs.registry }}/guestbook-frontend:${{ env.IMAGE_TAG }}
        docker push ${{ steps.login-ecr.outputs.registry }}/guestbook-backend:${{ env.IMAGE_TAG }}
        docker push ${{ steps.login-ecr.outputs.registry }}/guestbook-frontend:latest
        docker push ${{ steps.login-ecr.outputs.registry }}/guestbook-backend:latest

    - name: Set image output variables
      id: image-tags
      run: |
        echo "frontend-image=${{ steps.login-ecr.outputs.registry }}/guestbook-frontend:${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT
        echo "backend-image=${{ steps.login-ecr.outputs.registry }}/guestbook-backend:${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT

  terraform-plan:
    name: ğŸ“‹ Terraform Plan
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && (github.event.inputs.terraform_action == 'plan' || github.event.inputs.terraform_action == 'apply')
    environment: ${{ github.event.inputs.deploy_environment }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Init
      working-directory: docker-hello-world/infrastructure
      run: |
        echo "ğŸš€ Initializing Terraform..."
        terraform init

    - name: Terraform Plan
      working-directory: docker-hello-world/infrastructure
      run: |
        echo "ğŸ“‹ Creating Terraform plan for ${{ github.event.inputs.deploy_environment }} environment..."
        echo "Current directory: $(pwd)"
        echo "Terraform files:"
        ls -la *.tf
        echo "Environment files:"
        ls -la environments/
        echo "ğŸ”„ Refreshing Terraform state to sync with AWS..."
        terraform refresh \
          -var-file="environments/${{ github.event.inputs.deploy_environment }}.tfvars" \
          -var="frontend_image=${{ needs.build-and-push.outputs.frontend-image }}" \
          -var="backend_image=${{ needs.build-and-push.outputs.backend-image }}"
        terraform plan -input=false \
          -var-file="environments/${{ github.event.inputs.deploy_environment }}.tfvars" \
          -var="frontend_image=${{ needs.build-and-push.outputs.frontend-image }}" \
          -var="backend_image=${{ needs.build-and-push.outputs.backend-image }}" \
          -out=tfplan-${{ github.event.inputs.deploy_environment }}

    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ github.event.inputs.deploy_environment }}
        path: docker-hello-world/infrastructure/tfplan-${{ github.event.inputs.deploy_environment }}
        retention-days: 30

  terraform-apply:
    name: ğŸš€ Deploy Infrastructure
    needs: [build-and-push, terraform-plan]
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.terraform_action == 'apply'
    environment: ${{ github.event.inputs.deploy_environment }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan-${{ github.event.inputs.deploy_environment }}
        path: docker-hello-world/infrastructure/

    - name: Terraform Init
      working-directory: docker-hello-world/infrastructure
      run: |
        echo "ğŸš€ Initializing Terraform..."
        terraform init

    - name: Terraform Apply
      working-directory: docker-hello-world/infrastructure
      run: |
        echo "ğŸš€ Deploying infrastructure to ${{ github.event.inputs.deploy_environment }}..."
        terraform apply -auto-approve tfplan-${{ github.event.inputs.deploy_environment }}

    - name: Get deployment outputs
      id: terraform-outputs
      working-directory: docker-hello-world/infrastructure
      run: |
        echo "ğŸ“Š Getting deployment information..."
        APPLICATION_URL=$(terraform output -raw application_url)
        CLUSTER_NAME=$(terraform output -raw ecs_cluster_name)
        
        echo "application-url=$APPLICATION_URL" >> $GITHUB_OUTPUT
        echo "cluster-name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "environment=${{ github.event.inputs.deploy_environment }}" >> $GITHUB_OUTPUT

    - name: Update ECS services with latest images
      run: |
        echo "ğŸ”„ Updating ECS services with latest container images..."
        CLUSTER_NAME="${{ steps.terraform-outputs.outputs.cluster-name }}"
        ENVIRONMENT="${{ steps.terraform-outputs.outputs.environment }}"
        
        # Update backend service
        echo "Updating backend service..."
        aws ecs update-service \
          --cluster "$CLUSTER_NAME" \
          --service "$CLUSTER_NAME-backend" \
          --task-definition "$CLUSTER_NAME-backend" \
          --force-new-deployment
        
        # Update frontend service  
        echo "Updating frontend service..."
        aws ecs update-service \
          --cluster "$CLUSTER_NAME" \
          --service "$CLUSTER_NAME-frontend" \
          --task-definition "$CLUSTER_NAME-frontend" \
          --force-new-deployment
        
        echo "âœ… Container deployment triggered"

    - name: Wait for deployment to stabilize
      run: |
        echo "â³ Waiting for ECS services to stabilize..."
        CLUSTER_NAME="${{ steps.terraform-outputs.outputs.cluster-name }}"
        
        echo "Waiting for backend service..."
        aws ecs wait services-stable \
          --cluster "$CLUSTER_NAME" \
          --services "$CLUSTER_NAME-backend" \
          --cli-read-timeout 0 \
          --cli-connect-timeout 300 || echo "Backend service may still be deploying"
        
        echo "Waiting for frontend service..."
        aws ecs wait services-stable \
          --cluster "$CLUSTER_NAME" \
          --services "$CLUSTER_NAME-frontend" \
          --cli-read-timeout 0 \
          --cli-connect-timeout 300 || echo "Frontend service may still be deploying"
        
        echo "âœ… Services deployment completed"

    - name: Health Check and Troubleshooting
      run: |
        echo "ğŸ” Performing comprehensive health checks..."
        APPLICATION_URL="${{ steps.terraform-outputs.outputs.application-url }}"
        CLUSTER_NAME="${{ steps.terraform-outputs.outputs.cluster-name }}"
        
        echo "## ğŸ¥ Health Check Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check ECS service status
        echo "### ğŸ“¦ ECS Services Status"
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        aws ecs describe-services --cluster $CLUSTER_NAME --services guestbook-${{ github.event.inputs.deploy_environment }}-frontend guestbook-${{ github.event.inputs.deploy_environment }}-backend \
          --query 'services[*].{Name:serviceName,Running:runningCount,Desired:desiredCount,Status:status}' \
          --output table >> $GITHUB_STEP_SUMMARY || echo "ECS services check failed" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check target health
        echo "### ğŸ¯ Load Balancer Target Health"
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        
        # Frontend target health
        FRONTEND_TG_ARN=$(aws elbv2 describe-target-groups --names guestbook-${{ github.event.inputs.deploy_environment }}-frontend-tg --query 'TargetGroups[0].TargetGroupArn' --output text)
        echo "Frontend Targets:" >> $GITHUB_STEP_SUMMARY
        aws elbv2 describe-target-health --target-group-arn $FRONTEND_TG_ARN \
          --query 'TargetHealthDescriptions[*].{Target:Target.Id,Port:Target.Port,Health:TargetHealth.State,Reason:TargetHealth.Reason}' \
          --output table >> $GITHUB_STEP_SUMMARY || echo "Frontend target check failed" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Backend target health  
        BACKEND_TG_ARN=$(aws elbv2 describe-target-groups --names guestbook-${{ github.event.inputs.deploy_environment }}-backend-tg --query 'TargetGroups[0].TargetGroupArn' --output text)
        echo "Backend Targets:" >> $GITHUB_STEP_SUMMARY
        aws elbv2 describe-target-health --target-group-arn $BACKEND_TG_ARN \
          --query 'TargetHealthDescriptions[*].{Target:Target.Id,Port:Target.Port,Health:TargetHealth.State,Reason:TargetHealth.Reason}' \
          --output table >> $GITHUB_STEP_SUMMARY || echo "Backend target check failed" >> $GITHUB_STEP_SUMMARY
        
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check Parameter Store parameters
        echo "### ğŸ“‹ Parameter Store Configuration"
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        aws ssm describe-parameters --query 'Parameters[?contains(Name,`guestbook`)].{Name:Name,Type:Type}' --output table >> $GITHUB_STEP_SUMMARY || echo "Parameter Store check failed" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check recent logs for errors
        echo "### ğŸ“ Recent Backend Logs (Last 10 minutes)"
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        
        # Get latest backend log stream
        LATEST_LOG_STREAM=$(aws logs describe-log-streams \
          --log-group-name "/aws/ecs/guestbook-${{ github.event.inputs.deploy_environment }}" \
          --order-by LastEventTime --descending --max-items 1 \
          --query 'logStreams[?contains(logStreamName,`backend`)].logStreamName' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$LATEST_LOG_STREAM" ] && [ "$LATEST_LOG_STREAM" != "None" ]; then
          echo "Latest backend log stream: $LATEST_LOG_STREAM" >> $GITHUB_STEP_SUMMARY
          
          # Get recent log events (last 10 minutes)
          START_TIME=$(($(date +%s) * 1000 - 600000))
          aws logs get-log-events \
            --log-group-name "/aws/ecs/guestbook-${{ github.event.inputs.deploy_environment }}" \
            --log-stream-name "$LATEST_LOG_STREAM" \
            --start-time $START_TIME \
            --query 'events[?message].[timestamp,message]' \
            --output text | head -20 >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "No recent backend logs found" >> $GITHUB_STEP_SUMMARY
        else
          echo "No backend log streams found" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Test application connectivity
        echo "### ğŸŒ Application Connectivity Test"
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        
        echo "Testing frontend..." >> $GITHUB_STEP_SUMMARY
        FRONTEND_STATUS=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL" 2>&1 | tail -1 || echo "Connection failed")
        echo "Frontend: $FRONTEND_STATUS" >> $GITHUB_STEP_SUMMARY
        
        echo "Testing backend health endpoints..." >> $GITHUB_STEP_SUMMARY
        BACKEND_HEALTH=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/health" 2>&1 | tail -1 || echo "Connection failed")
        echo "Backend Health: $BACKEND_HEALTH" >> $GITHUB_STEP_SUMMARY
        
        BACKEND_READY=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/ready" 2>&1 | tail -1 || echo "Connection failed")
        echo "Backend Ready: $BACKEND_READY" >> $GITHUB_STEP_SUMMARY
        
        BACKEND_LIVE=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/live" 2>&1 | tail -1 || echo "Connection failed")
        echo "Backend Live: $BACKEND_LIVE" >> $GITHUB_STEP_SUMMARY
        
        # Test API functionality
        API_TEST=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/api/guestbook" 2>&1 | tail -1 || echo "API connection failed")
        echo "API Endpoint: $API_TEST" >> $GITHUB_STEP_SUMMARY
        
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

    - name: Deployment Summary
      run: |
        echo "## ğŸš€ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** ${{ github.event.inputs.deploy_environment }}" >> $GITHUB_STEP_SUMMARY
        echo "**Application URL:** ${{ steps.terraform-outputs.outputs.application-url }}" >> $GITHUB_STEP_SUMMARY
        echo "**ECS Cluster:** ${{ steps.terraform-outputs.outputs.cluster-name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Container Images" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend:** \`${{ needs.build-and-push.outputs.frontend-image }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend:** \`${{ needs.build-and-push.outputs.backend-image }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ğŸ” Troubleshooting" >> $GITHUB_STEP_SUMMARY
        echo "If services are unhealthy, check the health check results above." >> $GITHUB_STEP_SUMMARY
        echo "Common issues:" >> $GITHUB_STEP_SUMMARY
        echo "- **Parameter Store permissions** - Backend needs SSM access" >> $GITHUB_STEP_SUMMARY
        echo "- **Database connectivity** - Backend needs SSL config for RDS" >> $GITHUB_STEP_SUMMARY
        echo "- **Target registration** - Services take 2-3 minutes to become healthy" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # AUTOMATIC DEPLOYMENT ON PUSH TO MAIN
  # =============================================================================
  
  auto-deploy:
    name: ğŸš€ Auto Deploy to Demo
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: demo
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update ECS services automatically
      run: |
        echo "ğŸ”„ Auto-updating ECS services with latest code changes..."
        
        # Update backend service
        echo "Updating backend with latest code..."
        aws ecs update-service \
          --cluster "guestbook-demo-cluster" \
          --service "guestbook-demo-backend" \
          --force-new-deployment
        
        # Update frontend service  
        echo "Updating frontend with latest code..."
        aws ecs update-service \
          --cluster "guestbook-demo-cluster" \
          --service "guestbook-demo-frontend" \
          --force-new-deployment
        
        echo "âœ… Auto-deployment triggered"

    - name: Test deployment
      run: |
        echo "â³ Waiting 2 minutes for services to stabilize..."
        sleep 120
        
        echo "ğŸ” Testing deployment..."
        APPLICATION_URL="http://guestbook-demo-alb-1130710801.us-east-1.elb.amazonaws.com"
        
        echo "## ğŸ¥ Auto-Deployment Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Test all endpoints
        FRONTEND_TEST=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL" 2>&1 | tail -1 || echo "Connection failed")
        echo "Frontend: $FRONTEND_TEST" >> $GITHUB_STEP_SUMMARY
        
        HEALTH_TEST=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/health" 2>&1 | tail -1 || echo "Connection failed")
        echo "Health: $HEALTH_TEST" >> $GITHUB_STEP_SUMMARY
        
        READY_TEST=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/ready" 2>&1 | tail -1 || echo "Connection failed")
        echo "Ready: $READY_TEST" >> $GITHUB_STEP_SUMMARY
        
        LIVE_TEST=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/live" 2>&1 | tail -1 || echo "Connection failed")
        echo "Live: $LIVE_TEST" >> $GITHUB_STEP_SUMMARY
        
        API_TEST=$(curl -s -w "HTTP Status: %{http_code}" -m 10 "$APPLICATION_URL/api/guestbook" 2>&1 | tail -1 || echo "Connection failed")
        echo "API: $API_TEST" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ğŸš€ **Auto-deployment completed!** Your changes are now live." >> $GITHUB_STEP_SUMMARY

  terraform-destroy:
    name: ğŸ—‘ï¸ Destroy Infrastructure
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.terraform_action == 'destroy'
    environment: ${{ github.event.inputs.deploy_environment }}-destroy
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Init
      working-directory: docker-hello-world/infrastructure
      run: |
        echo "ğŸš€ Initializing Terraform..."
        terraform init

    - name: Terraform Destroy
      working-directory: docker-hello-world/infrastructure
      run: |
        echo "ğŸ—‘ï¸ Destroying infrastructure in ${{ github.event.inputs.deploy_environment }}..."
        terraform destroy -auto-approve \
          -var-file="environments/${{ github.event.inputs.deploy_environment }}.tfvars" \
          -var="frontend_image=nginx:alpine" \
          -var="backend_image=node:18-alpine"

    - name: Cleanup ECR images (optional)
      run: |
        echo "ğŸ§¹ Cleaning up ECR repositories..."
        aws ecr batch-delete-image --repository-name guestbook-frontend \
          --image-ids imageTag=latest imageTag=${{ env.IMAGE_TAG }} || true
        aws ecr batch-delete-image --repository-name guestbook-backend \
          --image-ids imageTag=latest imageTag=${{ env.IMAGE_TAG }} || true